# 同步？异步？阻塞？非阻塞？网络IO模型笔记

网络IO模型大概有这么几种：阻塞IO，非阻塞IO，多路IO复用IO，异步IO。（其实应该还有一种信号驱动IO，但极不常见，一般也就不讨论。）

这几种概念还是挺容易搞混的。今天本来是研究异步socket以及服务器如何使用更少资源维护更多连接的，结果看了好多关于IO模型的资料，这篇文字在这做一个总结。

总的来说，无论是阻塞、非阻塞还是多路复用，都是同步IO。网络上经常听到这种所谓2×2的说法，即存在同步阻塞、同步非阻塞、异步阻塞和异步非阻塞这四种IO组合。然而，这种定义上的事情大概还是要听权威的，在<<UNIX网络编程>>一书中，对同步和异步有如下说明

> POSIX defines these two terms as follows:
>
> · A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes.
>
> · An asynchronous I/O operation does not cause the requesting process to be blocked.
>
> Using these definitions, the first four I/O models—blocking, nonblocking, I/O multiplexing, and signal-driven I/O—are all synchronous because the actual I/O operation (recvfrom) blocks the process. Only the asynchronous I/O model matches the asynchronous I/O definition.

上面这段话讲得很清楚了，阻塞、非阻塞、多路IO复用，都是同步IO，真正的异步IO需要CPU的深度参与。换句话说，只有用户线程在操作IO的时候根本不去考虑IO的执行全部都交给CPU去完成，而自己只等待一个完成信号的时候，才是真正的异步IO。所以，拉一个子线程去轮询、去死循环，或者使用select、poll、epool，都不是异步。

下面对这几个概念逐一讨论一下，看看我能理解到什么程度。

下面的文字里都使用这个场景来讨论：客户端向服务器发送一个请求，并等待服务器返回响应内容，把响应内容显示出来。

阻塞和非阻塞还是很容易理解的，关键就在于线程在等待数据准备好的这个过程中，线程有没有被挂起。简单点说，假如客户端向服务器发送请求后，调用了一个函数来取得接收缓冲区里的数据，只要数据没准备好，这个函数就不返回，那么这就是阻塞。如果用GDB或者其他调试工具逐条调试的话，会发现执行到这里程序暂停了，不会再继续执行，直到服务器的消息发送过来。那非阻塞呢？就是调用的这个函数，每次都会向接收缓冲区里去查询数据是否已经到达，但无论到达与否都立即返回。那么客户端自己就得做一个定时或者轮询机制来反复调用这个函数，直到数据到达。这样至少表面上看程序或者线程没有挂起，它还在一条条不断执行，哪怕是一个循环。

这样子的话，我们可以想象一下，如果是在服务器端的话，我们怎么去维护大量的连接呢？毕竟服务器的数量和客户端的数量的差距很可能是几个数量级级别的，假如向一个客户端发送完等待确认就得阻塞在这里，那其他的客户请求就没办法处理了。这明显是不行的。所以一种简单的处理方法就是使用多线程，一个主线程用来监听端口，当和客户端建立起连接后就把它交给子线程去处理，主线程重新回去监听端口。这样即便子线程阻塞了，那也没关系，其他的客户请求不受影响。但这种方法太简单粗暴了，一个客户端连接就起一个线程，线程间的切换也是消耗系统资源的。其次本身一个连接也不一定就会长时间大量的进行IO操作，更可能的情况是这种数据交流也往往是阶段性的和短暂的，这样大量的子线程就显得没那么值得了。于是这种情况下，多路IO复用出现了。最典型的代表就是select模块，它提供了一种方法，可以同时监听若干个socket，其中任何一个可用了或者出现错误了或者超时了，都会返回。这样子就可以通过一个阻塞操作若干个客户连接了，甚至可以只用一个主线程和一个主线程就搞定一堆客户端的请求。

那么，同步是什么？其实这个概念放在不同语境下差别还是很大的。比如单纯的在通讯领域的话，同步意味着两台通讯设备使用了相同的频率，这样做可以提高数据传递的效率，因为同异步通讯相比，数据中减少了大量表示开始结束的特殊表示。

当然，这里讨论的同步是网络IO模型范畴的。我的理解是，IO操作从数据准备到数据拷贝直到最后数据操作完成，这一过程全都在用户线程的直接参与中完成的，就是同步IO。相反的，用户线程发起了IO操作，但并不从这一操作中得到返回值或者等待整个操作完成，而是把这个任务全权交给CPU来完成，并最后从CPU得到一个完成信号，这样做的是异步IO。关键就在于，用户线程有没有为IO操作分配任何本属于自己线程里的CPU时间，没有就是异步，有，那无论是起了子线程或者轮询或者死循环，那就是同步。